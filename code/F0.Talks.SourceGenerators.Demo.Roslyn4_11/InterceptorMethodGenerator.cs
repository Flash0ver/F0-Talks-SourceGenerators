using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.CodeDom.Compiler;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Globalization;
using System.Runtime.CompilerServices;

namespace F0.Talks.SourceGenerators.Demo.Roslyn4_11;

[Generator(LanguageNames.CSharp)]
internal sealed class InterceptorMethodGenerator : IIncrementalGenerator
{
    private static readonly string generatedCodeAttribute = $@"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(""{typeof(InterceptorMethodGenerator).Assembly.GetName().Name}"", ""{typeof(InterceptorMethodGenerator).Assembly.GetName().Version}"")]";
    private static readonly SymbolDisplayFormat format = SymbolDisplayFormat.FullyQualifiedFormat;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static void (IncrementalGeneratorPostInitializationContext context) =>
        {
            const string hintName = "System.Runtime.CompilerServices.InterceptableAttribute.g.cs";
            //language=c#
            string source = $$"""
                // <auto-generated/>
                #nullable enable

                namespace System.Runtime.CompilerServices;

                {{generatedCodeAttribute}}
                [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
                internal sealed class InterceptableAttribute : global::System.Attribute
                {
                }

                """;

            context.AddSource(hintName, source);
        });

#pragma warning disable RSEXPERIMENTAL002 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
        IncrementalValueProvider<ImmutableArray<(InterceptableLocation Location, string TypeName, Accessibility MethodAccessibility, bool IsStatic, string Parameter)>> provider =
            context.SyntaxProvider.CreateSyntaxProvider(
                static bool (SyntaxNode node, CancellationToken cancellationToken) =>
                {
                    return node is InvocationExpressionSyntax invocation
                        && invocation.Expression is MemberAccessExpressionSyntax
                        && invocation is { ArgumentList.Arguments.Count: 1 };
                },
                static (InterceptableLocation Location, string TypeName, Accessibility MethodAccessibility, bool IsStatic, string Parameter) (GeneratorSyntaxContext context, CancellationToken cancellationToken) =>
                {
                    Debug.Assert(context.Node is InvocationExpressionSyntax);
                    var invocation = Unsafe.As<InvocationExpressionSyntax>(context.Node);

                    Debug.Assert(invocation.Expression is MemberAccessExpressionSyntax);

                    SymbolInfo info = context.SemanticModel.GetSymbolInfo(invocation, cancellationToken);
                    if (info.Symbol is IMethodSymbol method
                        && method.Parameters.Length == 1)
                    {
                        INamedTypeSymbol? targetAttribute = context.SemanticModel.Compilation.GetTypeByMetadataName("System.Runtime.CompilerServices.InterceptableAttribute");

                        ImmutableArray<AttributeData> attributes = method.GetAttributes();
                        if (attributes.Any((AttributeData attribute) => SymbolEqualityComparer.Default.Equals(attribute.AttributeClass, targetAttribute)))
                        {
                            InterceptableLocation? location = context.SemanticModel.GetInterceptableLocation(invocation, cancellationToken);

                            if (location is not null)
                            {
                                return (location, method.ContainingType.ToDisplayString(format), method.DeclaredAccessibility, method.IsStatic, method.Parameters[0].Name);
                            }
                        }
                    }

                    return default;
                })
            .Where(static bool ((InterceptableLocation Location, string TypeName, Accessibility MethodAccessibility, bool IsStatic, string Parameter) source) => source.MethodAccessibility != default)
            .Collect();
#pragma warning restore RSEXPERIMENTAL002 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

#pragma warning disable RSEXPERIMENTAL002 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
        context.RegisterSourceOutput(provider, static void (SourceProductionContext context, ImmutableArray<(InterceptableLocation Location, string TypeName, Accessibility MethodAccessibility, bool IsStatic, string Parameter)> infos) =>
        {
            using StringWriter writer = new(CultureInfo.InvariantCulture);
            using IndentedTextWriter source = new(writer);

            //language=c#
            source.WriteLine($$"""
                // <auto-generated/>
                #nullable enable

                #pragma warning disable CS9113 // Parameter is unread.
                namespace System.Runtime.CompilerServices
                {
                    {{generatedCodeAttribute}}
                    [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
                    file sealed class InterceptsLocationAttribute(int version, string data) : global::System.Attribute
                    {
                    }
                }
                #pragma warning restore CS9113 // Parameter is unread.

                """);

            source.WriteLine("namespace Generated");
            source.WriteLine("{");
            source.Indent++;
            source.WriteLine(generatedCodeAttribute);
            source.WriteLine("file static class Interceptors");
            source.WriteLine("{");
            source.Indent++;
            for (int i = 0; i < infos.Length; i++)
            {
                var info = infos[i];
                string methodName = $"Interceptor{i}";

                source.WriteLine(info.Location.GetInterceptsLocationAttributeSyntax());
                string receiver = info.IsStatic ? "" : $"this {info.TypeName} receiver, ";
                source.WriteLine($"{SyntaxFacts.GetText(info.MethodAccessibility)} static string {methodName}({receiver}string {info.Parameter})");
                source.WriteLine("{");
                source.Indent++;
                source.WriteLine($$"""return $"Intercepted (Generator): {{{info.Parameter}}}";""");
                source.Indent--;
                source.WriteLine("}");
            }
            source.Indent--;
            source.WriteLine("}");
            source.Indent--;
            source.WriteLine("}");

            Debug.Assert(source.Indent == 0);
            context.AddSource("Interceptors.g.cs", writer.ToString());
        });
#pragma warning restore RSEXPERIMENTAL002 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
    }
}
