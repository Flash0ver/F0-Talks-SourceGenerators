using BenchmarkDotNet.Attributes;
using F0.CodeAnalysis.CSharp.Benchmarking;

namespace F0.Gen.ValueTypeEquality.UnitBenchmarks;

[MemoryDiagnoser]
public class ValueTypeEqualityGeneratorUnitBenchmarks
{
    private readonly CSharpIncrementalGeneratorBenchmark<IncrementalValueTypeEqualityGenerator> benchmark = new();
    //private readonly CSharpSourceGeneratorBenchmark<ValueTypeEqualityGenerator> benchmark = new();

    [GlobalSetup]
    public void Setup()
    {
        string code = @"
using System;

namespace Tests
{
    public class MyClass
    {
        public int Number { get; init; }
        public string Text { get; init; }
    }

    public partial class MyPartialClass
    {
        public int Number { get; init; }
        public string Text { get; init; }
    }

    public struct MyStruct
    {
        public int Number { get; init; }
        public string Text { get; init; }
    }

    public partial struct MyEquatableStruct : IEquatable<MyEquatableStruct>
    {
        public int Number { get; init; }
        public string Text { get; init; }

        public bool Equals(MyEquatableStruct other)
        {
            throw new NotImplementedException();
        }
    }

    public record class MyRecordClass(int Number, string Text);
    public partial record class MyPartialRecordClass(int Number, string Text);

    public record struct MyRecordStruct(int Number, string Text);
    public partial record struct MyPartialRecordStruct(int Number, string Text);

    public readonly record struct MyReadOnlyRecordStruct(int Number, string Text);
    public readonly partial record struct MyReadOnlyPartialRecordStruct(int Number, string Text);

    public readonly partial struct MyPartialStruct
    {
        public int Number { get; init; }
        public string Text { get; init; }
    }
}

public partial struct MyGlobalStruct
{
    public char Character { get; init; }
    public long Number { get; init; }
}
";

        benchmark.Initialize(new CSharpIncrementalGeneratorBenchmarkInitializationContext
        //benchmark.Initialize(new CSharpSourceGeneratorBenchmarkInitializationContext
        {
            Source = code,
        });
    }

    [Benchmark]
    public object Generate()
    {
        return benchmark.Invoke();
    }

    [GlobalCleanup]
    public void Cleanup()
    {
        string generatedStruct = @"// <auto-generated/>
#nullable enable

namespace Tests;

partial struct MyPartialStruct : global::System.IEquatable<MyPartialStruct>
{
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""F0.Gen.ValueTypeEquality"", ""1.0.0.0"")]
    public static bool operator ==(MyPartialStruct left, MyPartialStruct right)
    {
        return left.Equals(right);
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""F0.Gen.ValueTypeEquality"", ""1.0.0.0"")]
    public static bool operator !=(MyPartialStruct left, MyPartialStruct right)
    {
        return !(left == right);
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""F0.Gen.ValueTypeEquality"", ""1.0.0.0"")]
    public override int GetHashCode()
    {
        return global::System.HashCode.Combine(Number, Text);
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""F0.Gen.ValueTypeEquality"", ""1.0.0.0"")]
    public override bool Equals([global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] object? obj)
    {
        return obj is MyPartialStruct && Equals((MyPartialStruct)obj);
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""F0.Gen.ValueTypeEquality"", ""1.0.0.0"")]
    public bool Equals(MyPartialStruct other)
    {
        return global::System.Collections.Generic.EqualityComparer<int>.Default.Equals(Number, other.Number) && global::System.Collections.Generic.EqualityComparer<string>.Default.Equals(Text, other.Text);
    }
}
";

        string generatedGlobalStruct = @"// <auto-generated/>
#nullable enable


partial struct MyGlobalStruct : global::System.IEquatable<MyGlobalStruct>
{
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""F0.Gen.ValueTypeEquality"", ""1.0.0.0"")]
    public static bool operator ==(MyGlobalStruct left, MyGlobalStruct right)
    {
        return left.Equals(right);
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""F0.Gen.ValueTypeEquality"", ""1.0.0.0"")]
    public static bool operator !=(MyGlobalStruct left, MyGlobalStruct right)
    {
        return !(left == right);
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""F0.Gen.ValueTypeEquality"", ""1.0.0.0"")]
    public readonly override int GetHashCode()
    {
        return global::System.HashCode.Combine(Character, Number);
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""F0.Gen.ValueTypeEquality"", ""1.0.0.0"")]
    public readonly override bool Equals([global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] object? obj)
    {
        return obj is MyGlobalStruct && Equals((MyGlobalStruct)obj);
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""F0.Gen.ValueTypeEquality"", ""1.0.0.0"")]
    public readonly bool Equals(MyGlobalStruct other)
    {
        return global::System.Collections.Generic.EqualityComparer<char>.Default.Equals(Character, other.Character) && global::System.Collections.Generic.EqualityComparer<long>.Default.Equals(Number, other.Number);
    }
}
";

        benchmark.Inspect(new CSharpIncrementalGeneratorBenchmarkInspectionContext
        //benchmark.Inspect(new CSharpSourceGeneratorBenchmarkInspectionContext
        {
            Source = ("Tests.MyPartialStruct.ValueTypeEquality.g.cs", generatedStruct),
            AdditionalSources = { ("MyGlobalStruct.ValueTypeEquality.g.cs", generatedGlobalStruct) },
        });
    }
}
