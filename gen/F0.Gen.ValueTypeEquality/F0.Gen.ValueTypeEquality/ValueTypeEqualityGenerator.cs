using System.Diagnostics;
using System.Reflection;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace F0.Gen.ValueTypeEquality;

// [Generator(LanguageNames.CSharp)]
internal sealed class ValueTypeEqualityGenerator : ISourceGenerator
{
    private static readonly AssemblyName assembly = typeof(ValueTypeEqualityGenerator).Assembly.GetName();
    private static readonly string generatedCodeAttribute = $@"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(""{assembly.Name}"", ""{assembly.Version}"")]";

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(SyntaxReceiver.Create);
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxContextReceiver is not SyntaxReceiver receiver || receiver.CandidateStructs is null)
        {
            return;
        }

        Debug.Assert(receiver.CandidateStructs.Count > 0);

        foreach (INamedTypeSymbol @struct in receiver.CandidateStructs)
        {
            IPropertySymbol[] properties = @struct.GetMembers()
                .Where(static member => member.Kind == SymbolKind.Property)
                .Cast<IPropertySymbol>()
                .ToArray();

            string source = $@"// <auto-generated/>
#nullable enable

{(@struct.ContainingNamespace.IsGlobalNamespace ? string.Empty : $"namespace {@struct.ContainingNamespace};{Environment.NewLine}")}
partial struct {@struct.Name} : global::System.IEquatable<{@struct.Name}>
{{
    {generatedCodeAttribute}
    public static bool operator ==({@struct.Name} left, {@struct.Name} right)
    {{
        return left.Equals(right);
    }}

    {generatedCodeAttribute}
    public static bool operator !=({@struct.Name} left, {@struct.Name} right)
    {{
        return !(left == right);
    }}

    {generatedCodeAttribute}
    public override int GetHashCode()
    {{
        return global::System.HashCode.Combine({string.Join(", ", properties.Select(static property => property.Name))});
    }}

    {generatedCodeAttribute}
    public override bool Equals([global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] object? obj)
    {{
        return obj is {@struct.Name} && Equals(({@struct.Name})obj);
    }}

    {generatedCodeAttribute}
    public bool Equals({@struct.Name} other)
    {{
        return {string.Join(" && ", properties.Select(static property => $"global::System.Collections.Generic.EqualityComparer<{property.Type}>.Default.Equals({property.Name}, other.{property.Name})"))};
    }}
}}
";

            context.AddSource($"{@struct.Name}.ValueTypeEquality.g.cs", source);
        }
    }

    private sealed class SyntaxReceiver : ISyntaxContextReceiver
    {
        internal static ISyntaxContextReceiver Create()
        {
            return new SyntaxReceiver();
        }

        internal List<INamedTypeSymbol>? CandidateStructs { get; private set; }

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            if (context.Node is StructDeclarationSyntax @struct
                && @struct.Modifiers.Any(static modifier => modifier.IsKind(SyntaxKind.PartialKeyword)))
            {
                ISymbol? symbol = context.SemanticModel.GetDeclaredSymbol(@struct);

                if (symbol is INamedTypeSymbol type)
                {
                    INamedTypeSymbol? iEquatable = context.SemanticModel.Compilation.GetTypeByMetadataName("System.IEquatable`1");

                    if (!type.Interfaces.Any(@interface => @interface.Equals(iEquatable, SymbolEqualityComparer.Default)))
                    {
                        CandidateStructs ??= new List<INamedTypeSymbol>();
                        CandidateStructs.Add(type);
                    }
                }
            }
        }
    }
}
