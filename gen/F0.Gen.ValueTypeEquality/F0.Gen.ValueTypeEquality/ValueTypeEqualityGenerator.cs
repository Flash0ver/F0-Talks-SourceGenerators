using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace F0.Gen.ValueTypeEquality;

// [Generator(LanguageNames.CSharp)]
internal sealed class ValueTypeEqualityGenerator : ISourceGenerator
{
    private static readonly AssemblyName assembly = typeof(ValueTypeEqualityGenerator).Assembly.GetName();
    private static readonly string generatedCodeAttribute = $@"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(""{assembly.Name}"", ""{assembly.Version}"")]";
    private static readonly SymbolDisplayFormat format = SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.ExpandNullable | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier);

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(SyntaxReceiver.Create);
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxContextReceiver is not SyntaxReceiver receiver || receiver.CandidateStructs is null)
        {
            return;
        }

        Debug.Assert(receiver.CandidateStructs.Count > 0);

        IEnumerable<IGrouping<ISymbol?, INamedTypeSymbol>> group = receiver.CandidateStructs.GroupBy(static (INamedTypeSymbol @struct) => @struct, SymbolEqualityComparer.Default);
        foreach (IGrouping<ISymbol?, INamedTypeSymbol> structs in group)
        {
            INamedTypeSymbol @struct = structs.First();
            string @namespace = @struct.ContainingNamespace.ToDisplayString();
            string @readonly = @struct.IsReadOnly
                ? String.Empty
                : "readonly ";

            IPropertySymbol[] properties = @struct.GetMembers()
                .Where(static member => member.Kind == SymbolKind.Property)
                .Select(static property => Unsafe.As<IPropertySymbol>(property))
                .ToArray();

            string source = $@"// <auto-generated/>
#nullable enable

{(@struct.ContainingNamespace.IsGlobalNamespace ? String.Empty : $"namespace {@namespace};{Environment.NewLine}")}
partial struct {@struct.Name} : global::System.IEquatable<{@struct.Name}>
{{
    {generatedCodeAttribute}
    public static bool operator ==({@struct.Name} left, {@struct.Name} right)
    {{
        return left.Equals(right);
    }}

    {generatedCodeAttribute}
    public static bool operator !=({@struct.Name} left, {@struct.Name} right)
    {{
        return !(left == right);
    }}

    {generatedCodeAttribute}
    public {@readonly}override int GetHashCode()
    {{
        return global::System.HashCode.Combine({String.Join(", ", properties.Select(static property => property.Name))});
    }}

    {generatedCodeAttribute}
    public {@readonly}override bool Equals([global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] object? obj)
    {{
        return obj is {@struct.Name} && Equals(({@struct.Name})obj);
    }}

    {generatedCodeAttribute}
    public {@readonly}bool Equals({@struct.Name} other)
    {{
        return {String.Join(" && ", properties.Select(static property => $"global::System.Collections.Generic.EqualityComparer<{property.Type.ToDisplayString(format)}>.Default.Equals({property.Name}, other.{property.Name})"))};
    }}
}}
";

            string qualifiedName = @struct.ContainingNamespace.IsGlobalNamespace
                ? @struct.Name
                : $"{@namespace}.{@struct.Name}";
            context.AddSource($"{qualifiedName}.ValueTypeEquality.g.cs", source);
        }
    }

    private sealed class SyntaxReceiver : ISyntaxContextReceiver
    {
        internal static ISyntaxContextReceiver Create()
        {
            return new SyntaxReceiver();
        }

        internal List<INamedTypeSymbol>? CandidateStructs { get; private set; }

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            if (context.Node is StructDeclarationSyntax @struct
                && @struct.Modifiers.Any(SyntaxKind.PartialKeyword))
            {
                ISymbol? symbol = context.SemanticModel.GetDeclaredSymbol(@struct, CancellationToken.None);

                if (symbol is INamedTypeSymbol type)
                {
                    INamedTypeSymbol? iEquatable = context.SemanticModel.Compilation.GetTypeByMetadataName("System.IEquatable`1");

                    if (!type.Interfaces.Any(@interface => @interface.OriginalDefinition.Equals(iEquatable, SymbolEqualityComparer.Default)))
                    {
                        CandidateStructs ??= new List<INamedTypeSymbol>();
                        CandidateStructs.Add(type);
                    }
                }
            }
        }
    }
}
