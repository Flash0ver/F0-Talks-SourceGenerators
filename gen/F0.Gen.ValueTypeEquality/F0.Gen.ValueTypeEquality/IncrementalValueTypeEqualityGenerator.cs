using System.Collections.Immutable;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace F0.Gen.ValueTypeEquality;

[Generator(LanguageNames.CSharp)]
internal sealed class IncrementalValueTypeEqualityGenerator : IIncrementalGenerator
{
    private static readonly AssemblyName assembly = typeof(ValueTypeEqualityGenerator).Assembly.GetName();
    private static readonly string generatedCodeAttribute = $@"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(""{assembly.Name}"", ""{assembly.Version}"")]";
    private static readonly SymbolDisplayFormat format = SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.ExpandNullable | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<StructContext> provider = context.SyntaxProvider
            .CreateSyntaxProvider(SyntacticPredicate, SemanticTransform)
            .Where(static (INamedTypeSymbol? type) => type is not null)
            .Collect()!
            .SelectMany(static (ImmutableArray<INamedTypeSymbol> types, CancellationToken _) => Deduplicate(types))
            .Select(static (INamedTypeSymbol type, CancellationToken _) => TransformType(type))
            .WithComparer(StructContextEqualityComparer.Instance);

        context.RegisterSourceOutput(provider, Execute);
    }

    private static bool SyntacticPredicate(SyntaxNode node, CancellationToken cancellationToken)
    {
        return node is StructDeclarationSyntax @struct
            && @struct.Modifiers.Any(SyntaxKind.PartialKeyword);
    }

    private static INamedTypeSymbol? SemanticTransform(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        Debug.Assert(context.Node is StructDeclarationSyntax);
        var @struct = Unsafe.As<StructDeclarationSyntax>(context.Node);

        INamedTypeSymbol? symbol = context.SemanticModel.GetDeclaredSymbol(@struct, cancellationToken);

        if (symbol is not null)
        {
            INamedTypeSymbol? iEquatable = context.SemanticModel.Compilation.GetTypeByMetadataName("System.IEquatable`1");

            if (!symbol.Interfaces.Any(@interface => @interface.OriginalDefinition.Equals(iEquatable, SymbolEqualityComparer.Default)))
            {
                return symbol;
            }
        }

        return null;
    }

    private static IEnumerable<INamedTypeSymbol> Deduplicate(ImmutableArray<INamedTypeSymbol> types)
    {
        HashSet<INamedTypeSymbol> set = new(SymbolEqualityComparer.Default);

        foreach (INamedTypeSymbol type in types)
        {
            _ = set.Add(type);
        }

        return set;
    }

    private static StructContext TransformType(INamedTypeSymbol type)
    {
        string? @namespace = type.ContainingNamespace.IsGlobalNamespace
            ? null
            : type.ContainingNamespace.ToDisplayString();
        string @readonly = type.IsReadOnly
            ? String.Empty
            : "readonly ";
        string name = type.Name;
        string qualifiedName = type.ContainingNamespace.IsGlobalNamespace
            ? name
            : $"{@namespace}.{name}";
        ImmutableArray<PropertyContext> properties = type.GetMembers()
            .Where(static member => member.Kind == SymbolKind.Property)
            .Select(TransformProperty)
            .ToImmutableArray();

        return new StructContext(@namespace, @readonly, name, qualifiedName, properties);
    }

    private static PropertyContext TransformProperty(ISymbol member)
    {
        Debug.Assert(member is IPropertySymbol);
        var property = Unsafe.As<IPropertySymbol>(member);

        string type = property.Type.ToDisplayString(format);
        string name = property.Name;

        return new PropertyContext(type, name);
    }

    private static void Execute(SourceProductionContext context, StructContext @struct)
    {
        string source = $@"// <auto-generated/>
#nullable enable

{(@struct.Namespace is null ? String.Empty : $"namespace {@struct.Namespace};{Environment.NewLine}")}
partial struct {@struct.Name} : global::System.IEquatable<{@struct.Name}>
{{
    {generatedCodeAttribute}
    public static bool operator ==({@struct.Name} left, {@struct.Name} right)
    {{
        return left.Equals(right);
    }}

    {generatedCodeAttribute}
    public static bool operator !=({@struct.Name} left, {@struct.Name} right)
    {{
        return !(left == right);
    }}

    {generatedCodeAttribute}
    public {@struct.ReadOnly}override int GetHashCode()
    {{
        return global::System.HashCode.Combine({String.Join(", ", @struct.Properties.Select(static property => property.Name))});
    }}

    {generatedCodeAttribute}
    public {@struct.ReadOnly}override bool Equals([global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] object? obj)
    {{
        return obj is {@struct.Name} && Equals(({@struct.Name})obj);
    }}

    {generatedCodeAttribute}
    public {@struct.ReadOnly}bool Equals({@struct.Name} other)
    {{
        return {String.Join(" && ", @struct.Properties.Select(static property => $"global::System.Collections.Generic.EqualityComparer<{property.Type}>.Default.Equals({property.Name}, other.{property.Name})"))};
    }}
}}
";

        context.AddSource($"{@struct.QualifiedName}.ValueTypeEquality.g.cs", source);
    }

    private readonly record struct StructContext(string? Namespace, string ReadOnly, string Name, string QualifiedName, ImmutableArray<PropertyContext> Properties);

    private readonly record struct PropertyContext(string Type, string Name);

    private sealed class StructContextEqualityComparer : EqualityComparer<StructContext>
    {
        private StructContextEqualityComparer() { }

        public static IEqualityComparer<StructContext> Instance { get; } = new StructContextEqualityComparer();

        public override bool Equals(StructContext x, StructContext y)
        {
            return x.Namespace == y.Namespace
                && x.ReadOnly == y.ReadOnly
                && x.Name == y.Name
                && x.QualifiedName == y.QualifiedName
                && x.Properties.SequenceEqual(y.Properties, PropertyContextEqualityComparer.Instance);
        }

        public override int GetHashCode(StructContext obj)
        {
            throw new NotImplementedException();
        }
    }

    private sealed class PropertyContextEqualityComparer : EqualityComparer<PropertyContext>
    {
        private PropertyContextEqualityComparer() { }

        public static IEqualityComparer<PropertyContext> Instance { get; } = new PropertyContextEqualityComparer();

        public override bool Equals(PropertyContext x, PropertyContext y)
        {
            return x.Type == y.Type
                && x.Name == y.Name;
        }

        public override int GetHashCode(PropertyContext obj)
        {
            throw new NotImplementedException();
        }
    }
}
