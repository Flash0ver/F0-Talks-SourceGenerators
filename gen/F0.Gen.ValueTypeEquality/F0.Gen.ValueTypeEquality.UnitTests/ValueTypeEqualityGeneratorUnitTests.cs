using Microsoft.CodeAnalysis.Testing;
using Xunit;
using VerifyCS = F0.Gen.ValueTypeEquality.UnitTests.Verifiers.CSharpIncrementalGeneratorVerifier<F0.Gen.ValueTypeEquality.IncrementalValueTypeEqualityGenerator>;
//using VerifyCS = F0.Gen.ValueTypeEquality.UnitTests.Verifiers.CSharpSourceGeneratorVerifier<F0.Gen.ValueTypeEquality.ValueTypeEqualityGenerator>;

namespace F0.Gen.ValueTypeEquality.UnitTests;

public class ValueTypeEqualityGeneratorUnitTests
{
    [Fact]
    public async Task Generator_NoCandidates_AddNoSources()
    {
        string code = @"
using System;

namespace Tests
{
    public class MyClass
    {
        public int Number { get; init; }
        public string Text { get; init; }
    }

    public partial class MyPartialClass
    {
        public int Number { get; init; }
        public string Text { get; init; }
    }

    public struct MyStruct
    {
        public int Number { get; init; }
        public string Text { get; init; }
    }

    public partial struct MyEquatableStruct : IEquatable<MyEquatableStruct>
    {
        public int Number { get; init; }
        public string Text { get; init; }

        public bool Equals(MyEquatableStruct other)
        {
            throw new NotImplementedException();
        }
    }

    public record class MyRecordClass(int Number, string Text);
    public partial record class MyPartialRecordClass(int Number, string Text);

    public record struct MyRecordStruct(int Number, string Text);
    public partial record struct MyPartialRecordStruct(int Number, string Text);

    public readonly record struct MyReadOnlyRecordStruct(int Number, string Text);
    public readonly partial record struct MyReadOnlyPartialRecordStruct(int Number, string Text);
}
";

        await VerifyCS.VerifyGeneratorAsync(code, DiagnosticResult.EmptyDiagnosticResults);
    }

    [Fact]
    public async Task Generator_WithCandidates_AddPartialStructs()
    {
        string code = @"
using System;

#nullable enable

namespace Tests
{
    public partial struct MyPartialStruct
    {
        public int Number { get; init; }
    }
}

namespace Tests
{
    public readonly partial struct MyPartialStruct
    {
        public string Text { get; init; }
    }
}

namespace Optional
{
    public partial struct MyPartialStruct : IDisposable
    {
        public bool? Value { get; init; }
        public System.String? Reference { get; init; }
        public IEquatable<Nullable<bool>>? Interface { get; init; }
        public IComparable<string>?[]? Array { get; init; }

        public void Dispose()
        {
        }
    }
}

public partial struct MyGlobalStruct
{
    public char Character { get; init; }
    public long Number { get; init; }
}
";

        string generatedStruct = @"// <auto-generated/>
#nullable enable

namespace Tests;

partial struct MyPartialStruct : global::System.IEquatable<MyPartialStruct>
{
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""F0.Gen.ValueTypeEquality"", ""1.0.0.0"")]
    public static bool operator ==(MyPartialStruct left, MyPartialStruct right)
    {
        return left.Equals(right);
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""F0.Gen.ValueTypeEquality"", ""1.0.0.0"")]
    public static bool operator !=(MyPartialStruct left, MyPartialStruct right)
    {
        return !(left == right);
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""F0.Gen.ValueTypeEquality"", ""1.0.0.0"")]
    public override int GetHashCode()
    {
        return global::System.HashCode.Combine(Number, Text);
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""F0.Gen.ValueTypeEquality"", ""1.0.0.0"")]
    public override bool Equals([global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] object? obj)
    {
        return obj is MyPartialStruct && Equals((MyPartialStruct)obj);
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""F0.Gen.ValueTypeEquality"", ""1.0.0.0"")]
    public bool Equals(MyPartialStruct other)
    {
        return global::System.Collections.Generic.EqualityComparer<int>.Default.Equals(Number, other.Number) && global::System.Collections.Generic.EqualityComparer<string>.Default.Equals(Text, other.Text);
    }
}
";

        string generatedOptionalStruct = @"// <auto-generated/>
#nullable enable

namespace Optional;

partial struct MyPartialStruct : global::System.IEquatable<MyPartialStruct>
{
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""F0.Gen.ValueTypeEquality"", ""1.0.0.0"")]
    public static bool operator ==(MyPartialStruct left, MyPartialStruct right)
    {
        return left.Equals(right);
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""F0.Gen.ValueTypeEquality"", ""1.0.0.0"")]
    public static bool operator !=(MyPartialStruct left, MyPartialStruct right)
    {
        return !(left == right);
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""F0.Gen.ValueTypeEquality"", ""1.0.0.0"")]
    public readonly override int GetHashCode()
    {
        return global::System.HashCode.Combine(Value, Reference, Interface, Array);
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""F0.Gen.ValueTypeEquality"", ""1.0.0.0"")]
    public readonly override bool Equals([global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] object? obj)
    {
        return obj is MyPartialStruct && Equals((MyPartialStruct)obj);
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""F0.Gen.ValueTypeEquality"", ""1.0.0.0"")]
    public readonly bool Equals(MyPartialStruct other)
    {
        return global::System.Collections.Generic.EqualityComparer<global::System.Nullable<bool>>.Default.Equals(Value, other.Value) && global::System.Collections.Generic.EqualityComparer<string?>.Default.Equals(Reference, other.Reference) && global::System.Collections.Generic.EqualityComparer<global::System.IEquatable<global::System.Nullable<bool>>?>.Default.Equals(Interface, other.Interface) && global::System.Collections.Generic.EqualityComparer<global::System.IComparable<string>?[]?>.Default.Equals(Array, other.Array);
    }
}
";

        string generatedGlobalStruct = @"// <auto-generated/>
#nullable enable


partial struct MyGlobalStruct : global::System.IEquatable<MyGlobalStruct>
{
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""F0.Gen.ValueTypeEquality"", ""1.0.0.0"")]
    public static bool operator ==(MyGlobalStruct left, MyGlobalStruct right)
    {
        return left.Equals(right);
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""F0.Gen.ValueTypeEquality"", ""1.0.0.0"")]
    public static bool operator !=(MyGlobalStruct left, MyGlobalStruct right)
    {
        return !(left == right);
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""F0.Gen.ValueTypeEquality"", ""1.0.0.0"")]
    public readonly override int GetHashCode()
    {
        return global::System.HashCode.Combine(Character, Number);
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""F0.Gen.ValueTypeEquality"", ""1.0.0.0"")]
    public readonly override bool Equals([global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] object? obj)
    {
        return obj is MyGlobalStruct && Equals((MyGlobalStruct)obj);
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""F0.Gen.ValueTypeEquality"", ""1.0.0.0"")]
    public readonly bool Equals(MyGlobalStruct other)
    {
        return global::System.Collections.Generic.EqualityComparer<char>.Default.Equals(Character, other.Character) && global::System.Collections.Generic.EqualityComparer<long>.Default.Equals(Number, other.Number);
    }
}
";

        await VerifyCS.VerifyGeneratorAsync(code,
            ("Tests.MyPartialStruct.ValueTypeEquality.g.cs", generatedStruct),
            ("Optional.MyPartialStruct.ValueTypeEquality.g.cs", generatedOptionalStruct),
            ("MyGlobalStruct.ValueTypeEquality.g.cs", generatedGlobalStruct));
    }
}
