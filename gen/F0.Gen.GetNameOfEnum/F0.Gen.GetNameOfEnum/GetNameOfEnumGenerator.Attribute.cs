using System.Reflection;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace F0.Gen.GetNameOfEnum;

internal partial class GetNameOfEnumGenerator
{
    private const string GetNameOfEnumAttributeName = "Roslyn.Generated.GetNameOfEnumAttribute";

    private static readonly AssemblyName assemblyName = typeof(GetNameOfEnumGenerator).Assembly.GetName();
    private static readonly string generatedCodeAttribute = $@"global::System.CodeDom.Compiler.GeneratedCodeAttribute(""{assemblyName.Name}"", ""{assemblyName.Version}"")";

    private static readonly string GetNameOfEnumAttribute = $@"// <auto-generated/>
#nullable enable

namespace Roslyn.Generated;

[{generatedCodeAttribute}]
[global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
internal sealed class GetNameOfEnumAttribute : global::System.Attribute
{{
}}
";

    private static bool HasAttribute(MethodDeclarationSyntax candidate, string attributeName, SemanticModel semanticModel, CancellationToken cancellationToken)
    {
        foreach (AttributeListSyntax attributeList in candidate.AttributeLists)
        {
            foreach (AttributeSyntax attribute in attributeList.Attributes)
            {
                SymbolInfo info = semanticModel.GetSymbolInfo(attribute, cancellationToken);
                ISymbol? symbol = info.Symbol;

                if (symbol is IMethodSymbol method
                    && method.ContainingType.ToDisplayString().Equals(attributeName, StringComparison.Ordinal))
                {
                    return true;
                }
            }
        }

        return false;
    }
}
