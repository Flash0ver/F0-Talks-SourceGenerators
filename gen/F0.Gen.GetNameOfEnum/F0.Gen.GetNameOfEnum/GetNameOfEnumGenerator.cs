using System.CodeDom.Compiler;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace F0.Gen.GetNameOfEnum;

[Generator(LanguageNames.CSharp)]
internal sealed partial class GetNameOfEnumGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static (IncrementalGeneratorPostInitializationContext context) =>
        {
            context.AddSource($"{GetNameOfEnumAttributeName}.g.cs", GetNameOfEnumAttribute);
        });

        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (SyntaxNode syntaxNode, CancellationToken cancellationToken) =>
                {
                    return syntaxNode is MethodDeclarationSyntax
                    {
                        AttributeLists.Count: > 0,
                        ParameterList.Parameters.Count: 1,
                    } method
                        && method.Modifiers.Any(SyntaxKind.PartialKeyword)
                        && method.Parent is TypeDeclarationSyntax type
                        && type.Modifiers.Any(SyntaxKind.PartialKeyword);
                },
                static (GeneratorSyntaxContext context, CancellationToken cancellationToken) =>
                {
                    Debug.Assert(context.Node is MethodDeclarationSyntax);
                    Debug.Assert(context.Node.Parent is TypeDeclarationSyntax);

                    var method = Unsafe.As<MethodDeclarationSyntax>(context.Node);
                    var type = Unsafe.As<TypeDeclarationSyntax>(context.Node.Parent);

                    var methodSymbol = context.SemanticModel.GetDeclaredSymbol(method, cancellationToken);
                    Debug.Assert(methodSymbol is not null);

                    if (!HasAttribute(method, GetNameOfEnumAttributeName, context.SemanticModel, cancellationToken))
                    {
                        return default;
                    }

                    var param = methodSymbol.Parameters.Single();

                    if (methodSymbol.ReturnType.SpecialType == SpecialType.System_String
                        && param.Type.TypeKind == TypeKind.Enum)
                    {
                        return (methodName: method.Identifier.ValueText,
                            modifiers: method.Modifiers.ToString(),
                            enumType: param.Type.ToDisplayString(Formats.GlobalAlias),
                            paramName: param.Name,
                            keyword: type.Keyword.ToString(),
                            isNullable: methodSymbol.ReturnType.NullableAnnotation == NullableAnnotation.Annotated,
                            constants: param.Type.GetMembers().Where(static member => member.Kind is SymbolKind.Field).Select(static member => member.ToDisplayString(Formats.GlobalAlias)).ToImmutableArray(),
                            typeName: methodSymbol.ContainingType.Name,
                            nameSpace: methodSymbol.ContainingNamespace.ToDisplayString(),
                            isGlobal: methodSymbol.ContainingNamespace.IsGlobalNamespace);
                    }

                    return default;
                })
            .Where(static method => method != default)
            .WithComparer(MyEqualityComparer.Instance)
            .Collect()
            .SelectMany(static (methods, cancellationToken) => methods.GroupBy(static method => (method.nameSpace, method.typeName)));

        context.RegisterSourceOutput(provider, static (context, values) =>
        {
            var value = values.First();

            StringBuilder builder = new();
            using StringWriter writer = new(builder, CultureInfo.InvariantCulture);
            using IndentedTextWriter text = new(writer, IndentedTextWriter.DefaultTabString);

            text.WriteLine("// <auto-generated/>");
            text.WriteLine("#nullable enable");
            text.WriteLine();

            if (!value.isGlobal)
            {
                text.WriteLine($"namespace {value.nameSpace};");
                text.WriteLine();
            }

            text.WriteLine($"partial {value.keyword} {value.typeName}");
            text.OpenBlock();

            foreach (var item in values)
            {
                string nullable = item.isNullable ? "?" : "";
                string suppress = item.isNullable ? "" : "!";

                text.WriteLine($"{item.modifiers} string{nullable} {item.methodName}({item.enumType} {item.paramName})");
                text.OpenBlock();

                text.WriteLine($"return {item.paramName} switch");
                text.OpenBlock();
                foreach (var constant in item.constants)
                {
                    text.WriteLine($"{constant} => nameof({constant}),");
                }
                text.WriteLine($"_ => null{suppress},");
                text.CloseBlockSemicolon();

                text.CloseBlock();
                text.WriteLineNoTabs();
            }

            builder.Length -= Environment.NewLine.Length;
            text.CloseBlock();

            Debug.Assert(text.Indent == 0);

            string hintName = value.isGlobal
                ? $"{value.typeName}.GetNameOfEnum.g.cs"
                : $"{value.nameSpace}.{value.typeName}.GetNameOfEnum.g.cs";
            context.AddSource(hintName, writer.ToString());
        });
    }
}
